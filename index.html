<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite/1v1.lol Lite++ (Connected Demo)</title>
    <style>
        /* Styles mostly unchanged */
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; font-family: sans-serif; text-shadow: 1px 1px 2px black; }
        #instructions { position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; font-size: 13px; z-index: 10; pointer-events: auto; }
         #instructions span { display: block; margin-bottom: 3px;}
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; border-radius: 50%; border: 1px solid black; transform: translate(-50%, -50%); z-index: 5; }
        #build-mode-indicator { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 8px; font-size: 16px; z-index: 10; border: 1px solid #555; }
        #ammo-indicator { position: absolute; bottom: 20px; right: 20px; background-color: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 8px; font-size: 16px; z-index: 10; border: 1px solid #555; }
        #connection-status { position: absolute; top: 10px; right: 10px; color: #ffcc00; font-family: sans-serif; font-size: 14px; background-color: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 5px; z-index: 10; }
        /* Style for targeted build highlight */
        .targeted-build-highlight { outline: 2px solid yellow; } /* Applied via JS */
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="instructions">
             <span>Controls:</span>
             <span>- WASD: Move | SPACE: Jump</span>
             <span>- MOUSE: Look | CLICK: Shoot / Build</span>
             <span>- ARROW KEYS: Look (Alt)</span>
             <span>- Q: Toggle Build Mode</span>
             <span>- G: Delete Own Build (Aim)</span> <!-- Added Delete key -->
             <span>- Build Keys (Build Mode):</span>
             <span>  Z: Wall | X: Floor | C: Ramp | V: Cone</span>
        </div>
        <div id="crosshair"></div>
        <div id="build-mode-indicator">Mode: Combat</div>
        <div id="ammo-indicator">Ammo: ∞</div>
        <div id="connection-status">Connecting...</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <!-- Import Maps -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
            "cannon-es-debugger": "https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js" // Optional debugger
        }
    }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        // import CannonDebugger from 'cannon-es-debugger'; // Optional

        // --- Core Setup ---
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        let physicsWorld;
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();
        const raycaster = new THREE.Raycaster();
        // const cannonDebugger = CannonDebugger(scene, physicsWorld); // Optional

        // --- Game State & Config ---
        let isPointerLocked = false; let isInBuildMode = false;
        const BuildType = { NONE: 0, WALL: 1, FLOOR: 2, RAMP: 3, CONE: 4 };
        let currentBuildType = BuildType.WALL;
        const buildGridSize = 3.0; const buildReach = 10.0;
        const placedBuilds = new Map(); // Map<buildId, { mesh, body, health, type, builderId }>
        const buildHealthDefaults = { [BuildType.WALL]: 150, [BuildType.FLOOR]: 120, [BuildType.RAMP]: 130, [BuildType.CONE]: 100 };
        const shootDamage = 25;
        const moveSpeed = 12; const jumpForce = 11; // Slightly higher jump for gravity

        // --- Networking State ---
        let ws; let localPlayerId = null; const otherPlayers = new Map();
        const connectionStatusElement = document.getElementById('connection-status');
        let targetedBuildId = null; // Track which build is aimed at for deletion/editing highlight

        // --- UI Elements ---
        const buildModeIndicator = document.getElementById('build-mode-indicator');

        // --- Renderer ---
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.9; // Adjusted exposure
        const fogColor = 0xadd8e6; // Lighter blue fog
        scene.fog = new THREE.Fog(fogColor, 40, 150); // Adjusted fog distance
        renderer.setClearColor(fogColor);

        // --- Camera ---
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        let cameraTarget = new THREE.Vector3(); let cameraDistance = 4.0;
        let cameraShoulderOffset = new THREE.Vector3(0.5, 0.2, 0);
        let cameraPitch = 0.3; let cameraYaw = 0;

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Slightly brighter ambient
        const hemiLight = new THREE.HemisphereLight(0xB1E1FF, 0x707070, 0.7); // Adjusted ground color/intensity
        scene.add(hemiLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly softer sun
        directionalLight.position.set(40, 60, 30); directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 200; // Increased shadow range
        directionalLight.shadow.camera.left = -60; directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60; directionalLight.shadow.camera.bottom = -60;
        directionalLight.shadow.bias = -0.0005; // Adjust shadow bias slightly
        scene.add(directionalLight);
        // scene.add(new THREE.CameraHelper(directionalLight.shadow.camera));

        // --- Skybox (Using different reliable URLs) ---
        const skyboxPath = 'https://threejs.org/examples/textures/cube/skybox/';
        const skyboxUrls = [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ];
        const skyboxTexture = cubeTextureLoader.setPath(skyboxPath).load(skyboxUrls);
        scene.background = skyboxTexture; // Apply as background

        // --- Materials & Textures ---
        // Ground Texture (Example)
        const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping; groundTexture.repeat.set(80, 80);
        groundTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.9, metalness: 0.1 });

        // Wood Build Material (Example using different texture set)
        const woodBaseColor = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
        const woodRoughness = textureLoader.load('https://threejs.org/examples/textures/hardwood2_roughness.jpg');
        const woodNormal = textureLoader.load('https://threejs.org/examples/textures/hardwood2_normal.jpg');
        [woodBaseColor, woodRoughness, woodNormal].forEach(tex => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1,1); // Adjust tiling per build piece size
        });
        const woodBuildMaterial = new THREE.MeshStandardMaterial({
             map: woodBaseColor, roughnessMap: woodRoughness, normalMap: woodNormal,
             roughness: 1.0, metalness: 0.0, side: THREE.DoubleSide
        });

        // Brick Build Material (Example)
        const brickBaseColor = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
        const brickRoughness = textureLoader.load('https://threejs.org/examples/textures/brick_roughness.jpg');
        const brickNormal = textureLoader.load('https://threejs.org/examples/textures/brick_bump.jpg'); // Using bump as pseudo-normal
         [brickBaseColor, brickRoughness, brickNormal].forEach(tex => {
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1,1); // Adjust tiling
        });
        const brickBuildMaterial = new THREE.MeshStandardMaterial({
             map: brickBaseColor, roughnessMap: brickRoughness, normalMap: brickNormal,
             roughness: 0.9, metalness: 0.1, side: THREE.DoubleSide
        });

        // Player Material
        const playerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.6, metalness: 0.2 });
        const playerHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.7, metalness: 0.1 });

        // Preview Materials
        const previewMaterialValid = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.4, transparent: true, depthWrite: false });
        const previewMaterialInvalid = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.4, transparent: true, depthWrite: false });
        const targetHighlightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, opacity: 0.3, transparent: true, depthWrite: false, side: THREE.BackSide }); // For highlighting


        // --- Physics Setup ---
        physicsWorld = new CANNON.World({
            gravity: new CANNON.Vec3(0, -28, 0), // Slightly stronger gravity
            allowSleep: true
        });
        physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
        physicsWorld.solver.iterations = 15; // More solver iterations for stability
        // physicsWorld.solver.tolerance = 0.001; // Adjust solver tolerance if needed

        const baseMaterial = new CANNON.Material('base');
        const playerPhysMat = new CANNON.Material('player');
        const playerBaseContact = new CANNON.ContactMaterial(playerPhysMat, baseMaterial, { friction: 0.2, restitution: 0.0 }); // Slightly more friction
        physicsWorld.addContactMaterial(playerBaseContact);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(300, 300); const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2; groundMesh.receiveShadow = true; scene.add(groundMesh);
        const groundShape = new CANNON.Plane(); const groundBody = new CANNON.Body({ mass: 0, material: baseMaterial, shape: groundShape });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.userData = { type: 'ground' }; physicsWorld.addBody(groundBody);

        // --- Player ---
        const playerHeight = 1.8; const playerRadius = 0.4; const playerHeadRadius = 0.25;
        const playerGroup = new THREE.Group(); const torsoGeometry = new THREE.BoxGeometry(playerRadius * 1.8, playerHeight * 0.6, playerRadius); const playerTorso = new THREE.Mesh(torsoGeometry, playerBodyMaterial); playerTorso.castShadow = true; playerTorso.position.y = playerHeight * 0.3; playerGroup.add(playerTorso); const headGeometry = new THREE.SphereGeometry(playerHeadRadius, 16, 12); const playerHead = new THREE.Mesh(headGeometry, playerHeadMaterial); playerHead.castShadow = true; playerHead.position.y = playerHeight * 0.6 + playerHeadRadius * 0.9; playerGroup.add(playerHead); scene.add(playerGroup);
        const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius)); const playerBody = new CANNON.Body({ mass: 75, position: new CANNON.Vec3(0, playerHeight / 2 + 1.0, 0), shape: playerShape, material: playerPhysMat, fixedRotation: true, allowSleep: false, linearDamping: 0.2 }); playerBody.userData = { type: 'player', id: null }; physicsWorld.addBody(playerBody);

         // --- Other Player Representation ---
         function createOtherPlayerMesh() { /* Unchanged */ return null; } // Placeholder

        // --- Building System Setup ---
        const buildPreviewMeshes = {}; const buildGeometries = {}; const buildShapes = {};
        const buildMaterials = { // Assign materials per type
            [BuildType.WALL]: brickBuildMaterial,
            [BuildType.FLOOR]: woodBuildMaterial,
            [BuildType.RAMP]: woodBuildMaterial,
            [BuildType.CONE]: woodBuildMaterial,
        };

        // Wall
        const wallSizeVec = new CANNON.Vec3(buildGridSize / 2, buildGridSize / 2, 0.1); buildGeometries[BuildType.WALL] = new THREE.BoxGeometry(buildGridSize, buildGridSize, 0.2); buildShapes[BuildType.WALL] = new CANNON.Box(wallSizeVec); buildPreviewMeshes[BuildType.WALL] = new THREE.Mesh(buildGeometries[BuildType.WALL], previewMaterialValid);
        // Floor
        const floorSizeVec = new CANNON.Vec3(buildGridSize / 2, 0.1, buildGridSize / 2); buildGeometries[BuildType.FLOOR] = new THREE.BoxGeometry(buildGridSize, 0.2, buildGridSize); buildShapes[BuildType.FLOOR] = new CANNON.Box(floorSizeVec); buildPreviewMeshes[BuildType.FLOOR] = new THREE.Mesh(buildGeometries[BuildType.FLOOR], previewMaterialValid);

        // Ramp (Using ConvexPolyhedron for better physics - complex setup)
        const rampLength = buildGridSize * Math.SQRT2;
        buildGeometries[BuildType.RAMP] = new THREE.BoxGeometry(buildGridSize, 0.2, rampLength); buildGeometries[BuildType.RAMP].translate(0, 0.1, 0); buildGeometries[BuildType.RAMP].rotateX(Math.PI / 4); buildGeometries[BuildType.RAMP].translate(0, buildGridSize / 2 - 0.1, 0);
        // Define vertices for the ramp physics shape (a wedge)
        const rampVerts = [
            new CANNON.Vec3( buildGridSize/2, -0.1, -buildGridSize/2), // Bottom front right
            new CANNON.Vec3(-buildGridSize/2, -0.1, -buildGridSize/2), // Bottom front left
            new CANNON.Vec3( buildGridSize/2, -0.1,  buildGridSize/2), // Bottom back right
            new CANNON.Vec3(-buildGridSize/2, -0.1,  buildGridSize/2), // Bottom back left
            new CANNON.Vec3( buildGridSize/2, buildGridSize-0.1,  buildGridSize/2), // Top back right
            new CANNON.Vec3(-buildGridSize/2, buildGridSize-0.1,  buildGridSize/2)  // Top back left
        ];
        // Define faces (indices of vertices for each triangle)
        const rampFaces = [
            [0, 1, 2], [1, 3, 2], // Bottom face (flipped normal needed?)
            [0, 2, 4], // Right side triangle
            [1, 0, 4], [1, 4, 5], // Front slope
            [3, 1, 5], // Left side triangle
            [2, 3, 5], [2, 5, 4]  // Back face
        ];
        // Need to adjust face winding order if normals are wrong
        buildShapes[BuildType.RAMP] = new CANNON.ConvexPolyhedron({ vertices: rampVerts, faces: rampFaces });
        buildPreviewMeshes[BuildType.RAMP] = new THREE.Mesh(buildGeometries[BuildType.RAMP], previewMaterialValid);

        // Cone
        const coneRadius = buildGridSize / 2; const coneHeight = buildGridSize / 2; buildGeometries[BuildType.CONE] = new THREE.ConeGeometry(coneRadius, coneHeight, 4, 1); buildGeometries[BuildType.CONE].rotateY(Math.PI / 4); buildGeometries[BuildType.CONE].translate(0, coneHeight / 2, 0);
        // Using cylinder shape for cone physics remains a reasonable approximation here
        buildShapes[BuildType.CONE] = new CANNON.Cylinder(coneRadius, coneRadius, coneHeight, 8);
        buildPreviewMeshes[BuildType.CONE] = new THREE.Mesh(buildGeometries[BuildType.CONE], previewMaterialValid);

        Object.values(buildPreviewMeshes).forEach(mesh => { mesh.visible = false; scene.add(mesh); });

        // Add a mesh for highlighting targeted builds
        const targetHighlightMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), targetHighlightMaterial); // Geometry will be replaced
        targetHighlightMesh.visible = false;
        targetHighlightMesh.renderOrder = 1; // Render after normal objects
        scene.add(targetHighlightMesh);


        // --- Input Handling ---
        const keys = {};
        document.addEventListener('keydown', (event) => {
             keys[event.code] = true;
             if (event.code === 'KeyQ') { /* Toggle build mode */ }
             // *** Added 'G' key for deletion request ***
             else if (event.code === 'KeyG' && !isInBuildMode && isPointerLocked && targetedBuildId) {
                 requestDeleteBuild(targetedBuildId);
             }
             else if (isInBuildMode) { /* Build type selection Z/X/C/V */ }
        });
        // (keyup, click, pointerlockchange, pointerlockerror, mousemove listeners unchanged)


        // --- Movement State ---
        let canJump = false; let wasAirborne = false;
        // (checkGrounded function unchanged)


        // --- Audio ---
        let audioCtx; function initAudio() { /*...*/ } function playSound() { /*...*/ }
        // (Sound functions unchanged)


        // --- Building Logic ---
        // (getSnappedRotation, getBuildPlacement, updateBuildPreview, updateBuildPreviewVisibility unchanged)
        // addBuildPiece now uses assigned material and stores builderId
        function addBuildPiece(id, type, position, rotationEuler, builderId = null, health = null) {
             if (placedBuilds.has(id)) return placedBuilds.get(id);
             const geometry = buildGeometries[type]; const shape = buildShapes[type];
             const material = buildMaterials[type] || woodBuildMaterial; // Use assigned or default
             if (!geometry || !shape) return;

             const mesh = new THREE.Mesh(geometry, material); // Use specific material
             mesh.position.copy(position); mesh.rotation.copy(rotationEuler);
             mesh.castShadow = true; mesh.receiveShadow = true;
             mesh.userData = { id: id, type: 'build', buildType: type, builderId: builderId }; // Store builderId on mesh
             scene.add(mesh);

             const quaternion = new CANNON.Quaternion().setFromEuler(rotationEuler.x, rotationEuler.y, rotationEuler.z, 'XYZ');
             let bodyPosition = position.clone();
             // Note: ConvexPolyhedron doesn't need quaternion adjustment like the rotated box did
             if (type === BuildType.CONE) { bodyPosition = position.clone().add(new THREE.Vector3(0, coneHeight / 2, 0)); }

             const body = new CANNON.Body({ mass: 0, position: new CANNON.Vec3(bodyPosition.x, bodyPosition.y, bodyPosition.z), shape: shape, material: baseMaterial, quaternion: quaternion });
             body.userData = { id: id, type: 'build', buildType: type, builderId: builderId }; // Store builderId on body
             physicsWorld.addBody(body);

             const buildData = {
                 id: id, mesh: mesh, body: body,
                 health: health !== null ? health : (buildHealthDefaults[type] || 100),
                 type: type, builderId: builderId // Store builderId in map
             };
             placedBuilds.set(id, buildData);
             return buildData;
        }
        // (removeBuildPiece unchanged)
        // (placeBuild unchanged - still sends message)
        // (damageBuild unchanged - still sends DESTROY_BUILD if local health <= 0)

        // *** NEW: Function to request manual deletion ***
        function requestDeleteBuild(buildId) {
            if (!buildId) return;
            const build = placedBuilds.get(buildId);
            // Optional client-side check (server validates anyway)
            if (build && build.builderId === localPlayerId) {
                console.log(`Requesting deletion of own build: ${buildId}`);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    sendMessage({ type: 'DELETE_BUILD', payload: { id: buildId } });
                }
            } else if (build) {
                console.log("Cannot request deletion: Not your build.");
            } else {
                 console.log("Cannot request deletion: Build not found locally.");
            }
        }

        // *** NEW: Raycast to find targeted build ***
        function updateTargetedBuild() {
            targetedBuildId = null; // Reset
            targetHighlightMesh.visible = false; // Hide highlight
            if (isInBuildMode || !isPointerLocked) return; // Only target in combat mode

            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const buildMeshes = Array.from(placedBuilds.values()).map(b => b.mesh);
            if (buildMeshes.length === 0) return;

            const intersects = raycaster.intersectObjects(buildMeshes, false); // Intersect only build meshes

            for (const intersect of intersects) {
                if (intersect.distance < buildReach) { // Check reach
                    const hitBuild = placedBuilds.get(intersect.object.userData.id);
                    if (hitBuild) {
                        targetedBuildId = hitBuild.id;
                        // Update and show highlight mesh
                        targetHighlightMesh.geometry = hitBuild.mesh.geometry; // Use same geometry
                        targetHighlightMesh.position.copy(hitBuild.mesh.position);
                        targetHighlightMesh.quaternion.copy(hitBuild.mesh.quaternion);
                         // Optional: Slightly scale up the highlight
                         // targetHighlightMesh.scale.setScalar(1.02);
                        targetHighlightMesh.visible = true;

                        // Add visual cue if it's deletable by local player
                         if (hitBuild.builderId === localPlayerId) {
                             targetHighlightMaterial.color.set(0x00FF00); // Green if deletable
                         } else {
                             targetHighlightMaterial.color.set(0xFFFF00); // Yellow if not owned
                         }

                        break; // Found the closest target
                    }
                }
            }
        }


        // --- Shooting Logic ---
        // (shoot and showRemoteShootEffect functions unchanged)


        function updateBuildModeUI() { /* Unchanged */ }

        // --- Networking ---
        // (connectWebSocket, sendMessage unchanged)
        // handleServerMessage updated to store builderId
        function handleServerMessage(message) {
             switch (message.type) {
                 case 'ASSIGN_ID': localPlayerId = message.payload.id; playerBody.userData.id = localPlayerId; break;
                 case 'GAME_STATE':
                     otherPlayers.forEach(p => { if(p.mesh) scene.remove(p.mesh); }); otherPlayers.clear();
                     placedBuilds.forEach(b => removeBuildPiece(b.id)); placedBuilds.clear();
                     message.payload.players.forEach(pState => { if (pState.id !== localPlayerId) updateOtherPlayer(pState); });
                     message.payload.builds.forEach(bState => {
                         // *** Store builderId when loading state ***
                         const build = addBuildPiece(bState.id, bState.type, new THREE.Vector3(bState.position.x, bState.position.y, bState.position.z), new THREE.Euler(bState.rotation.x, bState.rotation.y, bState.rotation.z, 'XYZ'), bState.builderId, bState.health);
                         // Health update already handled inside addBuildPiece if health is passed
                     });
                     break;
                 case 'PLAYER_JOIN': if (message.payload.id !== localPlayerId) updateOtherPlayer(message.payload); break;
                 case 'PLAYER_LEAVE': const pToRemove = otherPlayers.get(message.payload.id); if (pToRemove) { if (pToRemove.mesh) scene.remove(pToRemove.mesh); otherPlayers.delete(message.payload.id); } break;
                 case 'PLAYER_UPDATE': if (message.payload.id !== localPlayerId) updateOtherPlayer(message.payload); break;
                 case 'BUILD_PLACED':
                     // *** Store builderId on placement ***
                     addBuildPiece(message.payload.id, message.payload.type, new THREE.Vector3(message.payload.position.x, message.payload.position.y, message.payload.position.z), new THREE.Euler(message.payload.rotation.x, message.payload.rotation.y, message.payload.rotation.z, 'XYZ'), message.payload.builderId, message.payload.health);
                     break;
                 case 'BUILD_DESTROYED':
                     removeBuildPiece(message.payload.id);
                     // Only play sound if it wasn't a manual deletion confirmed back to us
                     if (!message.payload.deletedByOwner || message.payload.id !== targetedBuildId) {
                         playDestroySound();
                     }
                     // If the destroyed build was being targeted, hide highlight
                     if (message.payload.id === targetedBuildId) {
                         targetedBuildId = null;
                         targetHighlightMesh.visible = false;
                     }
                     break;
                 // (PLAYER_SHOOT_VISUAL, PLAYER_DAMAGE, BUILD_DAMAGE handlers unchanged)
                 // Optional: Handle DELETE_DENIED message from server
                 case 'DELETE_DENIED':
                     if (message.payload.id === targetedBuildId) {
                         console.log(`Server denied deletion of build ${message.payload.id}: ${message.payload.reason}`);
                         // Maybe flash highlight red?
                     }
                     break;
                 default: break;
             }
         }
        // (updateOtherPlayer, sendPlayerState functions unchanged)


        // --- Game Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);

            // --- Input & Movement ---
            // (Movement, Jumping, Arrow Keys unchanged from last working version)
             const moveDirection = new THREE.Vector3(0, 0, 0); const forward = new THREE.Vector3(); const right = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize(); right.crossVectors(forward, camera.up).normalize(); if (keys['KeyW']) moveDirection.add(forward); if (keys['KeyS']) moveDirection.sub(forward); if (keys['KeyA']) moveDirection.sub(right); if (keys['KeyD']) moveDirection.add(right); moveDirection.normalize(); playerBody.velocity.x = moveDirection.x * moveSpeed; playerBody.velocity.z = moveDirection.z * moveSpeed;
             const grounded = checkGrounded(); if (grounded && wasAirborne) wasAirborne = false; else if (!grounded) wasAirborne = true; canJump = grounded; if (keys['Space'] && canJump && localPlayerId) { playerBody.velocity.y = jumpForce; canJump = false; wasAirborne = true; playJumpSound(); }
             const horizontalLook = (keys['ArrowLeft'] ? 1 : 0) + (keys['ArrowRight'] ? -1 : 0); const verticalLook = (keys['ArrowUp'] ? -1 : 0) + (keys['ArrowDown'] ? 1 : 0); cameraYaw += horizontalLook * arrowKeyLookSpeed; cameraPitch += verticalLook * arrowKeyLookSpeed; cameraPitch = Math.max(-Math.PI / 2 * 0.8, Math.min(Math.PI / 2 * 0.8, cameraPitch));

            // --- Update Physics ---
            physicsWorld.step(1 / 60, deltaTime, 3);
            // cannonDebugger.update(); // Optional: Update debugger visuals

            // --- Sync Meshes & Player ---
             playerGroup.position.copy(playerBody.position); playerGroup.position.y -= playerHeight / 2; playerGroup.rotation.y = cameraYaw + Math.PI;
             otherPlayers.forEach(player => { if (player.mesh && player.mesh.visible) { const interpTargetPos = player.targetPosition.clone(); interpTargetPos.y -= playerHeight / 2; player.mesh.position.lerp(interpTargetPos, 0.15); player.mesh.quaternion.slerp(player.targetQuaternion, 0.15); } });

            // --- Update Build Preview & Targeting ---
            updateBuildPreview();
            updateTargetedBuild(); // Update which build is being aimed at

            // --- Update Camera ---
            // (Camera update/collision logic unchanged)
            const playerHeadPos = new THREE.Vector3(); playerHead.getWorldPosition(playerHeadPos); const camRight = new THREE.Vector3().crossVectors(camera.up, camera.getWorldDirection(new THREE.Vector3()).negate()).normalize(); const shoulderOffsetWorld = camRight.multiplyScalar(cameraShoulderOffset.x).add(camera.up.clone().multiplyScalar(cameraShoulderOffset.y)); const targetFocusPoint = playerHeadPos.clone().add(shoulderOffsetWorld); cameraTarget.lerp(targetFocusPoint, 0.2); const cameraOffset = new THREE.Vector3(shoulderOffsetWorld.x, shoulderOffsetWorld.y, cameraDistance); cameraOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), cameraPitch); cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw); const desiredCameraPosition = playerHeadPos.clone().add(cameraOffset); const camRayStart = targetFocusPoint; const camRayDir = desiredCameraPosition.clone().sub(camRayStart).normalize(); const camRay = new CANNON.Ray(new CANNON.Vec3(camRayStart.x, camRayStart.y, camRayStart.z), new CANNON.Vec3(camRayDir.x, camRayDir.y, camRayDir.z)); camRay.to = new CANNON.Vec3(desiredCameraPosition.x, desiredCameraPosition.y, desiredCameraPosition.z); const camResult = new CANNON.RaycastResult(); const camOptions = { skipBackfaces: true, collisionFilterMask: -1, collisionFilterGroup: -1 }; physicsWorld.raycastClosest(camRay.from, camRay.to, camOptions, camResult); let finalCameraDist = cameraDistance; if (camResult.hasHit && camResult.body !== playerBody) { const hitDist = camRayStart.distanceTo(camResult.hitPointWorld); finalCameraDist = Math.max(hitDist - 0.2, 0.5); } camera.position.copy(camRayStart).addScaledVector(camRayDir, finalCameraDist); camera.lookAt(cameraTarget);

            // --- Send Network Updates ---
            const now = time || performance.now(); if (now - lastNetworkUpdateTime > networkUpdateInterval) { sendPlayerState(); lastNetworkUpdateTime = now; }

            // --- Render ---
            renderer.render(scene, camera);
        }

        // --- Resize Listener ---
        // (Unchanged)

        // --- Initialization ---
        // (Unchanged)

    </script>
</body>
</html>
