<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite/1v1.lol Lite (HTML Demo)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks through to canvas */
            color: white;
            font-family: sans-serif;
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 13px;
            z-index: 10;
            pointer-events: auto; /* Allow interaction if needed */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px; /* Smaller dot */
            height: 4px;
            background-color: white;
            border-radius: 50%;
            border: 1px solid black; /* Add outline */
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        #build-mode-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10;
            border: 1px solid #555;
        }
         #ammo-indicator { /* Basic placeholder */
             position: absolute;
             bottom: 20px;
             right: 20px;
             background-color: rgba(0,0,0,0.7);
             padding: 8px 15px;
             border-radius: 8px;
             font-size: 16px;
             z-index: 10;
             border: 1px solid #555;
         }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="instructions">
            Controls:<br>
            - WASD: Move | SPACE: Jump<br>
            - MOUSE: Look | CLICK: Shoot / Build<br>
            - ARROW KEYS: Look (Alt)<br>
            - Q: Toggle Build Mode (Combat/Build)<br>
            - 1: Select Wall | 2: Select Floor | 3: Select Ramp<br>
        </div>
        <div id="crosshair"></div>
        <div id="build-mode-indicator">Mode: Combat</div>
         <div id="ammo-indicator">Ammo: âˆž</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <!-- Import Maps -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        // Optional: import CannonDebugRenderer from './utils/cannon-es-debugger.js'; // If you download/use a debugger

        // --- Core Setup ---
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        let physicsWorld;
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(); // For potential UI interaction later, not used for shooting raycast

        // --- Game State ---
        let isPointerLocked = false;
        let isInBuildMode = false;
        const BuildType = { NONE: 0, WALL: 1, FLOOR: 2, RAMP: 3 };
        let currentBuildType = BuildType.WALL;
        const buildGridSize = 2.0; // Fortnite-like grid size
        const buildReach = 8.0; // How far the player can build
        const placedBuilds = []; // Store { mesh, body }

        // --- UI Elements ---
        const buildModeIndicator = document.getElementById('build-mode-indicator');

        // --- Renderer ---
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        const fogColor = 0x87CEEB; // Light blue sky fog
        scene.fog = new THREE.Fog(fogColor, 20, 80);
        renderer.setClearColor(fogColor);

        // --- Camera ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        let cameraTarget = new THREE.Vector3();
        let cameraDistance = 5; // Closer camera typical for these games
        let cameraPitch = 0.3;
        let cameraYaw = 0;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 30, 15);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048; // Higher res shadow map
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -40;
        directionalLight.shadow.camera.right = 40;
        directionalLight.shadow.camera.top = 40;
        directionalLight.shadow.camera.bottom = -40;
        scene.add(directionalLight);
        // scene.add(new THREE.CameraHelper(directionalLight.shadow.camera));

        // --- Skybox ---
        const skyboxTexture = cubeTextureLoader.load([
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/px.jpg', 'https://threejs.org/examples/textures/cube/skyboxsun25deg/nx.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/py.jpg', 'https://threejs.org/examples/textures/cube/skyboxsun25deg/ny.jpg',
            'https://threejs.org/examples/textures/cube/skyboxsun25deg/pz.jpg', 'https://threejs.org/examples/textures/cube/skyboxsun25deg/nz.jpg'
        ]);
        scene.background = skyboxTexture;

        // --- Materials ---
        const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.9, metalness: 0.1 });

        // Simple placeholder "skin" for player
        const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, roughness: 0.5, metalness: 0.3 });

        // Build piece materials
        const woodTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
        const buildWallMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
        const buildFloorMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide }); // Floor visible from below
        const buildRampMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide });

        const previewMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            opacity: 0.5,
            transparent: true,
            depthWrite: false // Prevents z-fighting issues with preview
        });

        // --- Physics Setup ---
        physicsWorld = new CANNON.World({ gravity: new CANNON.Vec3(0, -20, 0) }); // Stronger gravity
        physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
        physicsWorld.solver.iterations = 10;
        physicsWorld.allowSleep = true;

        // Physics materials
        const concrete = new CANNON.Material('concrete'); // Generic material
        const playerPhysMat = new CANNON.Material('player');

        const playerConcreteContact = new CANNON.ContactMaterial(playerPhysMat, concrete, { friction: 0.1, restitution: 0.05 });
        physicsWorld.addContactMaterial(playerConcreteContact);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: concrete, shape: groundShape });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        physicsWorld.addBody(groundBody);

        // --- Player ---
        const playerHeight = 1.8;
        const playerRadius = 0.4; // Using capsule or cylinder is better, but box is simpler for now
        const playerSize = { width: playerRadius * 2, height: playerHeight, depth: playerRadius * 2 };
        // Mesh is slightly different for visual appeal (cylinder)
        const playerGeometry = new THREE.CylinderGeometry(playerRadius, playerRadius, playerHeight, 16);
        const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.castShadow = true;
        playerMesh.geometry.translate(0, playerHeight / 2, 0); // Pivot at base
        playerMesh.position.y = 1; // Start on ground
        scene.add(playerMesh);

        // Physics Body (still a box for simplicity with Cannon-es basic shapes)
        const playerShape = new CANNON.Box(new CANNON.Vec3(playerSize.width / 2, playerSize.height / 2, playerSize.depth / 2));
        const playerBody = new CANNON.Body({
            mass: 75,
            position: new CANNON.Vec3(0, playerHeight / 2 + 0.1, 0), // Center mass
            shape: playerShape,
            material: playerPhysMat,
            fixedRotation: true,
            allowSleep: false,
            linearDamping: 0.1 // Add some damping
        });
        physicsWorld.addBody(playerBody);

        // --- Building System Setup ---
        const buildPreviewMeshes = {}; // Store preview meshes by type
        const buildGeometries = {}; // Store geometries by type

        // Wall
        buildGeometries[BuildType.WALL] = new THREE.BoxGeometry(buildGridSize, buildGridSize, 0.2);
        buildPreviewMeshes[BuildType.WALL] = new THREE.Mesh(buildGeometries[BuildType.WALL], previewMaterial);
        buildPreviewMeshes[BuildType.WALL].visible = false;
        scene.add(buildPreviewMeshes[BuildType.WALL]);

        // Floor
        buildGeometries[BuildType.FLOOR] = new THREE.BoxGeometry(buildGridSize, 0.2, buildGridSize);
        buildPreviewMeshes[BuildType.FLOOR] = new THREE.Mesh(buildGeometries[BuildType.FLOOR], previewMaterial);
        buildPreviewMeshes[BuildType.FLOOR].visible = false;
        scene.add(buildPreviewMeshes[BuildType.FLOOR]);

        // Ramp (Simple Wedge - requires custom geometry or approximation)
        // Using a skewed box as a simple approximation
        buildGeometries[BuildType.RAMP] = new THREE.BoxGeometry(buildGridSize, 0.2, buildGridSize * Math.SQRT2); // Diagonal length
        buildGeometries[BuildType.RAMP].translate(0, 0, buildGridSize * Math.SQRT2 * 0.5 - buildGridSize*0.5); // Adjust pivot
        buildGeometries[BuildType.RAMP].rotateX(Math.PI / 4); // 45 degree angle
        buildGeometries[BuildType.RAMP].translate(0, buildGridSize * 0.5 - 0.1 , 0); // Lift base

        buildPreviewMeshes[BuildType.RAMP] = new THREE.Mesh(buildGeometries[BuildType.RAMP], previewMaterial);
        buildPreviewMeshes[BuildType.RAMP].visible = false;
        scene.add(buildPreviewMeshes[BuildType.RAMP]);

        // --- Input Handling ---
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;
            // Mode Switching
            if (event.code === 'KeyQ') {
                isInBuildMode = !isInBuildMode;
                updateBuildModeUI();
            }
            // Build Type Selection
            if (isInBuildMode) {
                if (event.code === 'Digit1') currentBuildType = BuildType.WALL;
                if (event.code === 'Digit2') currentBuildType = BuildType.FLOOR;
                if (event.code === 'Digit3') currentBuildType = BuildType.RAMP;
                updateBuildModeUI(); // Update UI in case type changed
            }
        });
        document.addEventListener('keyup', (event) => { keys[event.code] = false; });

        // Pointer Lock & Actions (Shoot/Build)
        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock({ unadjustedMovement: true });
            } else {
                // Action depends on mode
                if (isInBuildMode) {
                    placeBuild();
                } else {
                    shoot();
                }
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            // Hide/show preview only if pointer is locked (avoids preview showing when tabbed out)
            updateBuildPreviewVisibility();
        });
        document.addEventListener('pointerlockerror', (error) => console.error('Pointer lock error:', error));

        // Mouse Look
        const lookSensitivity = 0.003;
        const arrowKeyLookSpeed = 0.03;
        document.addEventListener('mousemove', (event) => {
            if (!isPointerLocked) return;
            cameraYaw -= event.movementX * lookSensitivity;
            cameraPitch -= event.movementY * lookSensitivity;
            cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraPitch));
        });

        // --- Movement & State ---
        const moveSpeed = 7; // Slightly faster base speed
        const jumpForce = 9; // Adjusted for gravity
        let canJump = false;
        let wasAirborne = false;
        // Ground check remains similar
        const groundCheckRayC = new CANNON.Ray(new CANNON.Vec3(), new CANNON.Vec3(0, -1, 0));
        const raycastResultC = new CANNON.RaycastResult();
        const groundCheckDistance = playerHeight / 2 + 0.15;

        function checkGrounded() {
            const start = playerBody.position;
            groundCheckRayC.from.copy(start);
            groundCheckRayC.to.copy(start);
            groundCheckRayC.to.y -= groundCheckDistance;
            raycastResultC.reset();
            // Raycast options: Check against everything EXCEPT the player itself
             const options = {
                // collisionFilterMask: ~PLAYER_GROUP // Example if using collision groups
                // collisionFilterGroup: ~PLAYER_GROUP
                 skipBackfaces: true,
                 collisionFilterMask: -1 // Check against all groups for now
             };
            physicsWorld.raycastClosest(groundCheckRayC.from, groundCheckRayC.to, options, raycastResultC);
            return raycastResultC.hasHit && raycastResultC.distance <= groundCheckDistance + 0.01; // Small tolerance
        }

        // --- Audio ---
        let audioCtx;
        document.addEventListener('click', () => { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }, { once: true });

        function playSound(type, freq1, freq2, duration, vol) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq1, audioCtx.currentTime);
            if (freq2) osc.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration * 0.8);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        const playJumpSound = () => playSound('sine', 440, 880, 0.15, 0.2);
        const playShootSound = () => playSound('square', 150, 100, 0.1, 0.3);
        const playBuildSound = () => playSound('sawtooth', 200, 250, 0.15, 0.25);
        const playImpactSound = () => playSound('triangle', 300, 50, 0.1, 0.4);

        // --- Building Logic ---
        function getBuildPlacement() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera); // Ray from center screen
            const intersects = raycaster.intersectObjects(scene.children, true); // Check against all scene objects initially

            let validPlacement = null;

            for (const intersect of intersects) {
                // Ignore player, preview meshes, skybox etc. Find first valid surface (ground or existing build).
                if (intersect.object === playerMesh || intersect.object === buildPreviewMeshes[currentBuildType] || intersect.distance > buildReach) continue;
                if (intersect.object === groundMesh || placedBuilds.some(b => b.mesh === intersect.object)) {

                    const point = intersect.point;
                    const normal = intersect.face.normal.clone();
                     // Transform normal to world space if necessary (usually it is)
                     if (intersect.object.matrixWorld) {
                         normal.transformDirection(intersect.object.matrixWorld).normalize();
                     }


                    // Snap placement point to grid center based on intersection point + normal
                    const snappedPos = new THREE.Vector3(
                        Math.round((point.x + normal.x * 0.01) / buildGridSize) * buildGridSize,
                        Math.round((point.y + normal.y * 0.01) / buildGridSize) * buildGridSize,
                        Math.round((point.z + normal.z * 0.01) / buildGridSize) * buildGridSize
                    );

                    // Adjust position based on build type (center vs base)
                    let finalPos = snappedPos.clone();
                    let finalRot = new THREE.Euler(0, 0, 0); // Use Euler for simplicity here

                    // Calculate rotation based on player view and normal (simplified)
                    const playerDirection = new THREE.Vector3();
                    camera.getWorldDirection(playerDirection);
                    playerDirection.y = 0; // Ignore vertical component for horizontal rotation
                    playerDirection.normalize();

                    // Determine dominant axis for alignment (simplistic)
                    const angle = Math.atan2(playerDirection.x, playerDirection.z);
                    // Snap angle to 90 degrees
                    const snappedAngle = Math.round(angle / (Math.PI / 2)) * (Math.PI / 2);


                    if (currentBuildType === BuildType.WALL) {
                        finalPos.y += buildGridSize / 2; // Center vertically
                        finalRot.y = snappedAngle;
                         // Push slightly away from surface based on normal if needed
                        // finalPos.addScaledVector(normal, 0.1); // Optional adjustment
                    } else if (currentBuildType === BuildType.FLOOR) {
                        finalPos.y += 0.1; // Place slightly above the surface intersect point
                    } else if (currentBuildType === BuildType.RAMP) {
                        finalPos.y += 0.1; // Place base slightly above surface
                        finalRot.y = snappedAngle;
                         // Adjust position slightly so base aligns better - tricky
                         // finalPos.addScaledVector(playerDirection, -buildGridSize * 0.25); // Example adjustment
                    }


                    validPlacement = {
                        position: finalPos,
                        rotation: finalRot,
                        canPlace: true // Basic check, add collision check later
                    };
                    break; // Found valid placement surface
                }
            }

             // Check for collision with existing builds at the target spot (basic)
             if (validPlacement) {
                for(const build of placedBuilds) {
                    // Simple distance check - replace with bounding box overlap if needed
                    if (build.mesh.position.distanceTo(validPlacement.position) < buildGridSize * 0.7) {
                        validPlacement.canPlace = false;
                        break;
                    }
                }
                // Check distance from player feet - prevent building inside player
                const playerFeetPos = new THREE.Vector3().copy(playerBody.position);
                playerFeetPos.y -= playerHeight / 2;
                 if (playerFeetPos.distanceTo(validPlacement.position) < buildGridSize * 0.6) {
                     validPlacement.canPlace = false;
                 }
            }

            return validPlacement;
        }

        function updateBuildPreview() {
            if (!isInBuildMode || !isPointerLocked) {
                 Object.values(buildPreviewMeshes).forEach(mesh => mesh.visible = false);
                return;
            }

            const placement = getBuildPlacement();
            const previewMesh = buildPreviewMeshes[currentBuildType];

            if (placement && previewMesh) {
                previewMesh.position.copy(placement.position);
                previewMesh.rotation.copy(placement.rotation);
                previewMesh.material = placement.canPlace ? previewMaterial : previewMaterial.clone(); // Use clone to change color
                if (!placement.canPlace) previewMesh.material.color.set(0xff0000); // Red if cannot place
                else previewMesh.material.color.set(0x00ff00); // Green if can place

                 // Make only the current type visible
                 Object.entries(buildPreviewMeshes).forEach(([type, mesh]) => {
                     mesh.visible = (parseInt(type) === currentBuildType);
                 });

            } else {
                // Hide all if no valid placement found
                Object.values(buildPreviewMeshes).forEach(mesh => mesh.visible = false);
            }
        }
         function updateBuildPreviewVisibility() { // Helper called on pointer lock change
             if (!isInBuildMode || !isPointerLocked) {
                 Object.values(buildPreviewMeshes).forEach(mesh => mesh.visible = false);
             } // Else, updateBuildPreview in animate loop will handle it
         }

        function placeBuild() {
            const placement = getBuildPlacement();
            if (!placement || !placement.canPlace) return; // Can't place here

            let buildMesh;
            let buildBody;
            let buildShape;
            const position = placement.position;
            const rotation = placement.rotation; // THREE.Euler
            const quaternion = new CANNON.Quaternion().setFromEuler(rotation.x, rotation.y, rotation.z, 'XYZ');


            // Create Mesh and Physics Body based on type
            switch (currentBuildType) {
                case BuildType.WALL:
                    buildMesh = new THREE.Mesh(buildGeometries[BuildType.WALL], buildWallMaterial);
                    buildShape = new CANNON.Box(new CANNON.Vec3(buildGridSize / 2, buildGridSize / 2, 0.1)); // Thin box
                    break;
                case BuildType.FLOOR:
                    buildMesh = new THREE.Mesh(buildGeometries[BuildType.FLOOR], buildFloorMaterial);
                     buildShape = new CANNON.Box(new CANNON.Vec3(buildGridSize / 2, 0.1, buildGridSize / 2)); // Thin box
                    break;
                case BuildType.RAMP:
                     buildMesh = new THREE.Mesh(buildGeometries[BuildType.RAMP], buildRampMaterial);
                     // Ramps are complex for physics. Using an oriented box is an approximation.
                     // A ConvexPolyhedron shape is more accurate but much harder to set up.
                      const rampSize = buildGridSize * Math.SQRT2; // Length of the diagonal base
                      buildShape = new CANNON.Box(new CANNON.Vec3(buildGridSize / 2, 0.1, rampSize / 2));
                     // Need to apply the 45-degree rotation to the physics shape quaternion as well
                     const rampQuaternion = new CANNON.Quaternion();
                     rampQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 4);
                     quaternion.mult(rampQuaternion, quaternion); // Combine rotations

                    break;
                default: return; // Should not happen
            }

            buildMesh.position.copy(position);
            buildMesh.rotation.copy(rotation);
            buildMesh.castShadow = true;
            buildMesh.receiveShadow = true;
            scene.add(buildMesh);

            buildBody = new CANNON.Body({
                mass: 0, // Static
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: buildShape,
                material: concrete,
                quaternion: quaternion
            });
            physicsWorld.addBody(buildBody);
            placedBuilds.push({ mesh: buildMesh, body: buildBody });

            playBuildSound();
        }

        function updateBuildModeUI() {
             let typeStr = "";
             if (currentBuildType === BuildType.WALL) typeStr = "Wall";
             else if (currentBuildType === BuildType.FLOOR) typeStr = "Floor";
             else if (currentBuildType === BuildType.RAMP) typeStr = "Ramp";
             buildModeIndicator.textContent = isInBuildMode ? `Build: ${typeStr}` : "Mode: Combat";
        }

        // --- Shooting Logic ---
        function shoot() {
            if (!isPointerLocked) return; // Can't shoot if pointer not locked

            playShootSound();

            // Raycast from camera center
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObjects(scene.children, true); // Check everything

            let hitPoint = null;
            let hitObject = null;

            for (const intersect of intersects) {
                // Ignore player, preview meshes, very close hits (inside player?)
                if (intersect.object === playerMesh || Object.values(buildPreviewMeshes).includes(intersect.object) || intersect.distance < 0.5) continue;

                 hitPoint = intersect.point;
                 hitObject = intersect.object; // Could check if this is another player/destructible later
                 break; // Take the first valid hit
            }

            // Visual feedback
            const tracerMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });
            const startPoint = new THREE.Vector3();
            camera.getWorldPosition(startPoint); // Start tracer near camera
            // Move start point slightly forward so it doesn't start *in* the camera lens
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            startPoint.addScaledVector(direction, 0.5);


            const endPoint = hitPoint ? hitPoint : raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 100); // End far away if no hit
            const tracerGeometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);
            const tracerLine = new THREE.Line(tracerGeometry, tracerMaterial);
            scene.add(tracerLine);

            // Impact effect
            if (hitPoint) {
                playImpactSound();
                const impactGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const impactMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const impactSphere = new THREE.Mesh(impactGeometry, impactMaterial);
                impactSphere.position.copy(hitPoint);
                scene.add(impactSphere);
                // Remove impact/tracer after short delay
                setTimeout(() => {
                    scene.remove(impactSphere);
                    impactMaterial.dispose();
                    impactGeometry.dispose();
                }, 150);
            }

            setTimeout(() => {
                scene.remove(tracerLine);
                tracerMaterial.dispose();
                tracerGeometry.dispose();
            }, 100);

             // TODO: If hitObject is another player/build, apply damage/logic here
        }


        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); // Clamp delta time

            // --- Input & Movement ---
            const moveDirection = new THREE.Vector3(0, 0, 0);
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward); // Use camera direction for movement
            forward.y = 0;
            forward.normalize();
            right.crossVectors(camera.up, forward).normalize(); // Calculate right vector based on camera's up and forward

            if (keys['KeyW']) moveDirection.add(forward);
            if (keys['KeyS']) moveDirection.sub(forward);
            if (keys['KeyA']) moveDirection.sub(right);
            if (keys['KeyD']) moveDirection.add(right);
            moveDirection.normalize();

            const currentVelocity = playerBody.velocity;
            const targetVelocity = new CANNON.Vec3(
                moveDirection.x * moveSpeed,
                currentVelocity.y, // Preserve Y velocity (gravity/jump)
                moveDirection.z * moveSpeed
            );
            // Apply force for smoother acceleration/deceleration (optional)
            // const force = new CANNON.Vec3(
            //     (targetVelocity.x - currentVelocity.x) * playerBody.mass * 5,
            //     0,
            //     (targetVelocity.z - currentVelocity.z) * playerBody.mass * 5
            // );
            // playerBody.applyForce(force);
             // Direct velocity change for responsiveness
             playerBody.velocity.x = targetVelocity.x;
             playerBody.velocity.z = targetVelocity.z;

            // --- Jumping & Landing ---
            const grounded = checkGrounded();
            canJump = grounded;
             if (grounded && wasAirborne) {
                 // playLandingSound(); // Add if you have one
                 wasAirborne = false;
             } else if (!grounded) {
                 wasAirborne = true;
             }

            if (keys['Space'] && canJump) {
                 playerBody.velocity.y = jumpForce; // Apply jump velocity directly
                 canJump = false;
                 wasAirborne = true;
                 playJumpSound();
            }


            // --- Arrow Key Camera ---
            const horizontalLook = (keys['ArrowLeft'] ? 1 : 0) + (keys['ArrowRight'] ? -1 : 0);
            const verticalLook = (keys['ArrowUp'] ? -1 : 0) + (keys['ArrowDown'] ? 1 : 0);
            cameraYaw += horizontalLook * arrowKeyLookSpeed;
            cameraPitch += verticalLook * arrowKeyLookSpeed;
            cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraPitch));


            // --- Update Physics ---
            physicsWorld.step(1 / 60, deltaTime, 3); // Fixed timestep

            // --- Sync Player Mesh ---
            playerMesh.position.copy(playerBody.position);
            playerMesh.position.y -= playerHeight / 2; // Adjust mesh pivot offset
            // Rotate player mesh to face camera yaw (visual only)
            playerMesh.rotation.y = cameraYaw + Math.PI; // Make cylinder face away from camera


            // --- Update Build Preview ---
            updateBuildPreview();


            // --- Update Camera ---
            const playerHeadPos = new THREE.Vector3().copy(playerBody.position); // Use physics body center
            // playerHeadPos.y += playerHeight * 0.4; // Aim target slightly higher than center mass
            cameraTarget.lerp(playerHeadPos, 0.2); // Smoothly follow player head

            const cameraOffset = new THREE.Vector3(0, 0, cameraDistance);
            cameraOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), cameraPitch);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

            const desiredCameraPosition = playerHeadPos.clone().add(cameraOffset);

            // Basic Camera Collision (Raycast from player head towards desired camera pos)
            const camRay = new CANNON.Ray(playerHeadPos, desiredCameraPosition);
            const camResult = new CANNON.RaycastResult();
             const camOptions = { skipBackfaces: true, collisionFilterMask: -1 /* Check all */ };
             physicsWorld.raycastClosest(camRay.from, camRay.to, camOptions, camResult);

            if (camResult.hasHit) {
                // Hit something, move camera closer than desired
                 const hitDist = camResult.distance;
                 // Subtract a small amount to prevent clipping into the wall
                 const finalDist = Math.max(hitDist - 0.3, 1.0); // Minimum distance of 1 unit
                 camera.position.copy(camRay.from).addScaledVector(camRay.direction, finalDist);

            } else {
                // No hit, lerp smoothly to desired position
                camera.position.lerp(desiredCameraPosition, 0.15);
            }

            camera.lookAt(cameraTarget);


            // --- Render ---
            renderer.render(scene, camera);
        }

        // --- Resize Listener ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

        // --- Start ---
        updateBuildModeUI(); // Initial UI setup
        animate();

    </script>
</body>
</html>
