<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortnite/1v1.lol Lite++ (HTML Demo)</title>
    <style>
        /* (Keep previous styles: body, canvas, ui-container, instructions, crosshair, build-mode-indicator, ammo-indicator) */
         body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #ui-container { /* ... */ }
        #instructions { /* ... (Update Keys) */
            position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.6);
            padding: 10px; border-radius: 5px; font-size: 13px; z-index: 10; pointer-events: auto;
            color: white; font-family: sans-serif; text-shadow: 1px 1px 2px black;
         }
         #instructions span { display: block; margin-bottom: 3px;}

        #crosshair { /* ... */
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background-color: white; border-radius: 50%; border: 1px solid black;
            transform: translate(-50%, -50%); z-index: 5; pointer-events: none;
        }
        #build-mode-indicator { /* ... */
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 8px;
            font-size: 16px; z-index: 10; border: 1px solid #555;
            color: white; font-family: sans-serif; text-shadow: 1px 1px 2px black;
        }
        #ammo-indicator { /* ... */
             position: absolute; bottom: 20px; right: 20px; background-color: rgba(0,0,0,0.7);
             padding: 8px 15px; border-radius: 8px; font-size: 16px; z-index: 10;
             border: 1px solid #555; color: white; font-family: sans-serif; text-shadow: 1px 1px 2px black;
        }
         #connection-status {
             position: absolute;
             top: 10px;
             right: 10px;
             color: #ffcc00;
             font-family: sans-serif;
             font-size: 14px;
             background-color: rgba(0,0,0,0.6);
             padding: 5px 10px;
             border-radius: 5px;
             z-index: 10;
         }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="instructions">
             <span>Controls:</span>
             <span>- WASD: Move | SPACE: Jump</span>
             <span>- MOUSE: Look | CLICK: Shoot / Build</span>
             <span>- ARROW KEYS: Look (Alt)</span>
             <span>- Q: Toggle Build Mode</span>
             <span>- Build Keys (Build Mode):</span>
             <span>  Z: Wall | X: Floor | C: Ramp | V: Cone</span>
        </div>
        <div id="crosshair"></div>
        <div id="build-mode-indicator">Mode: Combat</div>
        <div id="ammo-indicator">Ammo: ∞</div>
        <div id="connection-status">Connecting...</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <!-- Import Maps -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Core Setup ---
        // (Scene, Clock, PhysicsWorld, TextureLoader, CubeTextureLoader, Raycaster setup as before)
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        let physicsWorld;
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();
        const raycaster = new THREE.Raycaster();


        // --- Game State & Config ---
        let isPointerLocked = false;
        let isInBuildMode = false;
        const BuildType = { NONE: 0, WALL: 1, FLOOR: 2, RAMP: 3, CONE: 4 }; // Added CONE
        let currentBuildType = BuildType.WALL;
        const buildGridSize = 3.0; // Slightly larger grid like some games
        const buildReach = 10.0;
        const placedBuilds = new Map(); // Use Map for easier lookup/removal by ID { id: { mesh, body, health, type } }
        let nextBuildId = 0; // Simple ID generation for client-side builds
        const buildHealth = { // Default health values
            [BuildType.WALL]: 150,
            [BuildType.FLOOR]: 120,
            [BuildType.RAMP]: 130,
            [BuildType.CONE]: 100,
        };
        const shootDamage = 25; // Damage per shot

        // --- Networking State ---
        let ws; // WebSocket connection
        let localPlayerId = null; // Assigned by server
        const otherPlayers = new Map(); // { id: { mesh, body (optional), targetPosition, targetQuaternion } }
        const connectionStatusElement = document.getElementById('connection-status');


        // --- UI Elements ---
        const buildModeIndicator = document.getElementById('build-mode-indicator');

        // --- Renderer ---
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better colors
        renderer.toneMappingExposure = 1.0;
        const fogColor = 0x87CEEB;
        scene.fog = new THREE.Fog(fogColor, 30, 120); // Adjusted fog distance
        renderer.setClearColor(fogColor);

        // --- Camera ---
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); // Slightly narrower FOV
        let cameraTarget = new THREE.Vector3();
        let cameraDistance = 4.0; // Closer default distance
        let cameraShoulderOffset = new THREE.Vector3(0.5, 0.2, 0); // Offset for over-the-shoulder feel (X, Y)
        let cameraPitch = 0.3;
        let cameraYaw = 0;

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.3)); // Lower ambient
        const hemiLight = new THREE.HemisphereLight(0xB1E1FF, 0xB97A20, 0.6); // Sky, Ground, Intensity
        scene.add(hemiLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // Slightly stronger sun
        directionalLight.position.set(30, 50, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 150; // Increased shadow distance
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);
        // scene.add(new THREE.CameraHelper(directionalLight.shadow.camera));


        // --- Skybox ---
        // (Same skybox as before)
        const skyboxTexture = cubeTextureLoader.load([ /* ... URLs ... */ ]);
        scene.background = skyboxTexture;


        // --- Materials & Textures ---
        // Example using textures from ambientCG.com / PolyHaven (ensure you check licenses)
        // Replace URLs with actual paths if hosting locally or use valid online URLs
        const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'); // Placeholder, use better one if found
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(80, 80);
        grassTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Improve texture filtering
        const groundMaterial = new THREE.MeshStandardMaterial({ map: grassTexture, roughness: 0.9, metalness: 0.1 });

        // Wood texture example
        const woodBaseColor = textureLoader.load('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/prototype/textures/pkg-1/texture_08.png'); // Example stylized wood
        const woodRoughness = textureLoader.load('https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/prototype/textures/pkg-1/roughness_08.png');
        woodBaseColor.wrapS = woodBaseColor.wrapT = THREE.RepeatWrapping;
        woodRoughness.wrapS = woodRoughness.wrapT = THREE.RepeatWrapping;
        woodBaseColor.repeat.set(2,2); woodRoughness.repeat.set(2,2); // Adjust tiling

        const buildMaterial = new THREE.MeshStandardMaterial({
             map: woodBaseColor,
             roughnessMap: woodRoughness,
             roughness: 0.8, // Base roughness
             metalness: 0.0,
             side: THREE.DoubleSide // Needed for floors/ramps/cones
        });

        // Basic player material (could load a texture too)
        const playerBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.6, metalness: 0.2 });
        const playerHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.7, metalness: 0.1 });

        const previewMaterialValid = new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity: 0.4, transparent: true, depthWrite: false });
        const previewMaterialInvalid = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.4, transparent: true, depthWrite: false });

        // --- Physics Setup ---
        // (World setup similar, maybe adjust gravity/iterations if needed)
        physicsWorld = new CANNON.World({ gravity: new CANNON.Vec3(0, -25, 0) });
        physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
        physicsWorld.solver.iterations = 12; // More iterations for stability
        physicsWorld.allowSleep = true;

        const baseMaterial = new CANNON.Material('base'); // Ground, builds
        const playerPhysMat = new CANNON.Material('player');
        const playerBaseContact = new CANNON.ContactMaterial(playerPhysMat, baseMaterial, { friction: 0.1, restitution: 0.0 });
        physicsWorld.addContactMaterial(playerBaseContact);


        // --- Ground ---
        // (Ground setup as before, using baseMaterial)
        const groundGeometry = new THREE.PlaneGeometry(300, 300); // Larger ground
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: baseMaterial, shape: groundShape });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        physicsWorld.addBody(groundBody);
        groundBody.userData = { type: 'ground' }; // Identify ground

        // --- Player ---
        const playerHeight = 1.8;
        const playerRadius = 0.4;
        const playerHeadRadius = 0.25;

        // Basic Dummy Model
        const playerGroup = new THREE.Group(); // Group to hold parts
        const torsoGeometry = new THREE.BoxGeometry(playerRadius * 1.8, playerHeight * 0.6, playerRadius);
        const playerTorso = new THREE.Mesh(torsoGeometry, playerBodyMaterial);
        playerTorso.castShadow = true;
        playerTorso.position.y = playerHeight * 0.3; // Position torso center
        playerGroup.add(playerTorso);

        const headGeometry = new THREE.SphereGeometry(playerHeadRadius, 16, 12);
        const playerHead = new THREE.Mesh(headGeometry, playerHeadMaterial);
        playerHead.castShadow = true;
        playerHead.position.y = playerHeight * 0.6 + playerHeadRadius * 0.9; // Position head above torso center
        playerGroup.add(playerHead);

        playerGroup.position.y = playerHeight / 2; // Initial position adjustment seems off, set in body
        scene.add(playerGroup);

        // Physics Body (Capsule is better, approximate with Box for simplicity here)
        // Using a box centered, slightly taller than wide
        const playerShape = new CANNON.Box(new CANNON.Vec3(playerRadius, playerHeight / 2, playerRadius));
        const playerBody = new CANNON.Body({
            mass: 75,
            position: new CANNON.Vec3(0, playerHeight / 2 + 1.0, 0), // Start higher
            shape: playerShape,
            material: playerPhysMat,
            fixedRotation: true,
            allowSleep: false,
            linearDamping: 0.2 // More damping
        });
        playerBody.userData = { type: 'player', id: null }; // Add ID later
        physicsWorld.addBody(playerBody);


         // --- Other Player Representation ---
         function createOtherPlayerMesh() {
            // Similar dummy model for network players
            const group = new THREE.Group();
            const torso = new THREE.Mesh(torsoGeometry.clone(), playerBodyMaterial.clone());
            torso.castShadow = true;
            torso.position.y = playerHeight * 0.3;
            group.add(torso);
            const head = new THREE.Mesh(headGeometry.clone(), playerHeadMaterial.clone());
            head.castShadow = true;
            head.position.y = playerHeight * 0.6 + playerHeadRadius * 0.9;
            group.add(head);
            group.visible = false; // Initially hidden
            scene.add(group);
            return group;
         }


        // --- Building System Setup ---
        const buildPreviewMeshes = {};
        const buildGeometries = {};
        const buildShapes = {}; // Store CANNON shapes too

        const buildSizeVec = new CANNON.Vec3(buildGridSize / 2, buildGridSize / 2, 0.1); // Wall half extents
        buildGeometries[BuildType.WALL] = new THREE.BoxGeometry(buildGridSize, buildGridSize, 0.2);
        buildShapes[BuildType.WALL] = new CANNON.Box(buildSizeVec);
        buildPreviewMeshes[BuildType.WALL] = new THREE.Mesh(buildGeometries[BuildType.WALL], previewMaterialValid);

        const floorSizeVec = new CANNON.Vec3(buildGridSize / 2, 0.1, buildGridSize / 2); // Floor half extents
        buildGeometries[BuildType.FLOOR] = new THREE.BoxGeometry(buildGridSize, 0.2, buildGridSize);
        buildShapes[BuildType.FLOOR] = new CANNON.Box(floorSizeVec);
        buildPreviewMeshes[BuildType.FLOOR] = new THREE.Mesh(buildGeometries[BuildType.FLOOR], previewMaterialValid);

        // Ramp (Approximated with a rotated thin box for physics)
        const rampLength = buildGridSize * Math.SQRT2; // Diagonal length
        buildGeometries[BuildType.RAMP] = new THREE.BoxGeometry(buildGridSize, 0.2, rampLength);
        buildGeometries[BuildType.RAMP].translate(0, 0.1, 0); // Move pivot slightly
        buildGeometries[BuildType.RAMP].rotateX(Math.PI / 4); // 45 deg visual rotation
        buildGeometries[BuildType.RAMP].translate(0, buildGridSize / 2 - 0.1, 0); // Lift base
        const rampShapeVec = new CANNON.Vec3(buildGridSize / 2, 0.1, rampLength / 2);
        buildShapes[BuildType.RAMP] = new CANNON.Box(rampShapeVec); // Physics box represents the slope base
        buildPreviewMeshes[BuildType.RAMP] = new THREE.Mesh(buildGeometries[BuildType.RAMP], previewMaterialValid);


        // Cone (Using THREE.ConeGeometry, CANNON.Cylinder for physics)
        const coneRadius = buildGridSize / 2;
        const coneHeight = buildGridSize / 2; // Make it a square based cone
        buildGeometries[BuildType.CONE] = new THREE.ConeGeometry(coneRadius, coneHeight, 4, 1); // 4 segments for pyramid look
        buildGeometries[BuildType.CONE].rotateY(Math.PI / 4); // Align flat sides with axes
        buildGeometries[BuildType.CONE].translate(0, coneHeight / 2, 0); // Pivot at base center
        // Physics Shape: Cylinder is a decent approximation
        buildShapes[BuildType.CONE] = new CANNON.Cylinder(coneRadius, coneRadius, coneHeight, 8); // Top/Bottom radius, height, segments
        buildPreviewMeshes[BuildType.CONE] = new THREE.Mesh(buildGeometries[BuildType.CONE], previewMaterialValid);


        Object.values(buildPreviewMeshes).forEach(mesh => {
            mesh.visible = false;
            scene.add(mesh);
        });

        // --- Input Handling ---
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;
            if (event.code === 'KeyQ') {
                isInBuildMode = !isInBuildMode;
                updateBuildModeUI();
                updateBuildPreviewVisibility(); // Show/hide preview immediately
            }
            if (isInBuildMode) {
                let buildChanged = true;
                if (event.code === 'KeyZ') currentBuildType = BuildType.WALL;
                else if (event.code === 'KeyX') currentBuildType = BuildType.FLOOR;
                else if (event.code === 'KeyC') currentBuildType = BuildType.RAMP;
                else if (event.code === 'KeyV') currentBuildType = BuildType.CONE; // Added V for Cone
                else buildChanged = false;

                if (buildChanged) updateBuildModeUI();
            }
        });
        document.addEventListener('keyup', (event) => { keys[event.code] = false; });

        // Pointer Lock & Actions
        document.addEventListener('click', () => {
             if (!audioCtx) initAudio(); // Init audio on first click
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock({ unadjustedMovement: true });
            } else {
                handlePrimaryAction();
            }
        });

        function handlePrimaryAction() {
             if (!localPlayerId) return; // Don't act if not connected/identified
             if (isInBuildMode) {
                placeBuild(); // Will now also send network message
             } else {
                shoot(); // Will now also send network message
             }
        }

        // (Pointer lock change/error listeners as before)
         document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            updateBuildPreviewVisibility();
        });
         document.addEventListener('pointerlockerror', (error) => console.error('Pointer lock error:', error));

        // Mouse Look
        const lookSensitivity = 0.0025; // Slightly lower sensitivity
        const arrowKeyLookSpeed = 0.03;
        document.addEventListener('mousemove', (event) => {
             if (!isPointerLocked) return;
             cameraYaw -= event.movementX * lookSensitivity;
             cameraPitch -= event.movementY * lookSensitivity;
             // Clamp vertical rotation more strictly for Fortnite feel
             cameraPitch = Math.max(-Math.PI / 2 * 0.8, Math.min(Math.PI / 2 * 0.8, cameraPitch));
        });

        // --- Movement & State ---
        // (Variables moveSpeed, jumpForce, canJump, wasAirborne as before)
        const moveSpeed = 7.5;
        const jumpForce = 10; // Adjust based on gravity
        let canJump = false;
        let wasAirborne = false;
        // (Ground check function similar, maybe adjust distance slightly)
         const groundCheckRayC = new CANNON.Ray(new CANNON.Vec3(), new CANNON.Vec3(0, -1, 0));
         const raycastResultC = new CANNON.RaycastResult();
         const groundCheckDistance = playerHeight / 2 + 0.1; // Check from center mass down

         function checkGrounded() { /* ... similar implementation ... */
             const start = playerBody.position;
             groundCheckRayC.from.copy(start);
             groundCheckRayC.to.copy(start);
             groundCheckRayC.to.y -= groundCheckDistance;
             raycastResultC.reset();
             const options = { collisionFilterMask: -1, skipBackfaces: true }; // Check everything
             physicsWorld.raycastClosest(groundCheckRayC.from, groundCheckRayC.to, options, raycastResultC);
             // Check if hit ground or a build piece
             const hitBody = raycastResultC.body;
             const isGroundedSurface = hitBody && (hitBody === groundBody || (hitBody.userData && hitBody.userData.type === 'build'));

             return raycastResultC.hasHit && isGroundedSurface && raycastResultC.distance <= groundCheckDistance + 0.05;
         }


        // --- Audio ---
        let audioCtx;
        function initAudio() { /* ... */ }
        function playSound(type, freq1, freq2, duration, vol) { /* ... */ }
        const playJumpSound = () => playSound('sine', 440, 880, 0.15, 0.2);
        const playShootSound = () => playSound('square', 150, 100, 0.1, 0.3);
        const playBuildSound = () => playSound('sawtooth', 200, 250, 0.15, 0.25);
        const playImpactSound = () => playSound('triangle', 300, 50, 0.1, 0.4);
        const playDestroySound = () => playSound('noise', 100, 50, 0.3, 0.4); // Noise for destruction


        // --- Building Logic ---
        function getSnappedRotation() {
            // Snap Yaw to nearest 90 degrees for walls/ramps/cones
            const snappedYaw = Math.round(cameraYaw / (Math.PI / 2)) * (Math.PI / 2);
            return new THREE.Euler(0, snappedYaw, 0, 'XYZ');
        }

        function getBuildPlacement() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const placementRay = raycaster.ray;

            // Filter potential intersects: ground and existing builds
            const intersectMeshes = [groundMesh, ...Array.from(placedBuilds.values()).map(b => b.mesh)];
            const intersects = raycaster.intersectObjects(intersectMeshes, false); // Don't check children

            let validPlacement = null;

            for (const intersect of intersects) {
                if (intersect.distance > buildReach) continue;

                const point = intersect.point;
                const normal = intersect.face.normal.clone();
                // Check if normal is needed - usually face normal is in local space
                // If object has rotation, transform normal to world space
                if (intersect.object !== groundMesh) { // Ground has no world rotation
                     normal.transformDirection(intersect.object.matrixWorld).normalize();
                } else {
                     // Ground normal is fixed (0, 1, 0) in world space if plane is flat
                     normal.set(0, 1, 0);
                }


                // Determine grid cell center based on intersection point
                 // Offset slightly along the normal *before* snapping
                 const offsetPoint = point.clone().addScaledVector(normal, 0.01);

                let snappedX = Math.round(offsetPoint.x / buildGridSize) * buildGridSize;
                let snappedY = Math.round(offsetPoint.y / buildGridSize) * buildGridSize;
                let snappedZ = Math.round(offsetPoint.z / buildGridSize) * buildGridSize;

                // Adjust Y placement based on build type
                let finalY = snappedY;
                if (currentBuildType === BuildType.WALL) finalY += buildGridSize / 2; // Center wall vertically
                else if (currentBuildType === BuildType.FLOOR) finalY += 0.1; // Place slightly above surface
                else if (currentBuildType === BuildType.RAMP) finalY += 0.1; // Place base slightly above surface
                else if (currentBuildType === BuildType.CONE) finalY += 0.1; // Place base slightly above

                const finalPos = new THREE.Vector3(snappedX, finalY, snappedZ);
                let finalRot = new THREE.Euler(0, 0, 0, 'XYZ'); // Default rotation

                // Apply snapped rotation for directional pieces
                if (currentBuildType === BuildType.WALL || currentBuildType === BuildType.RAMP || currentBuildType === BuildType.CONE) {
                    finalRot = getSnappedRotation();
                }


                 validPlacement = {
                    position: finalPos,
                    rotation: finalRot,
                    canPlace: true // Start assuming true
                 };
                break; // Found placement surface
            }

             // Validity Checks (Collision)
             if (validPlacement) {
                 const checkBounds = new THREE.Box3();
                 const previewGeom = buildGeometries[currentBuildType];
                 if (previewGeom) {
                    checkBounds.setFromObject(buildPreviewMeshes[currentBuildType], true); // Use preview mesh with correct transform

                    // 1. Check against existing builds (using physics bodies for broader check)
                    for(const build of placedBuilds.values()) {
                        // Simple AABB overlap check (could be more precise)
                        const buildBounds = new THREE.Box3().setFromObject(build.mesh);
                        if (checkBounds.intersectsBox(buildBounds)) {
                             // Allow minor overlap for adjacent pieces? Need better logic for grid adjacency.
                             // For now, any intersection = invalid (simplistic)
                             if(build.mesh.position.distanceTo(validPlacement.position) < 0.5) { // Crude proximity check
                                validPlacement.canPlace = false;
                                break;
                             }
                        }
                    }

                    // 2. Check against local player physics body
                    const playerBounds = new THREE.Box3().setFromObject(playerGroup); // Check visual mesh bounds
                    if (checkBounds.intersectsBox(playerBounds)) {
                         validPlacement.canPlace = false;
                     }

                    // 3. Check against other players (if any) - needs player physics representation
                     for (const other of otherPlayers.values()) {
                         if (other.mesh.visible) {
                             const otherBounds = new THREE.Box3().setFromObject(other.mesh);
                             if (checkBounds.intersectsBox(otherBounds)) {
                                 validPlacement.canPlace = false;
                                 break;
                             }
                         }
                     }
                 } else {
                     validPlacement.canPlace = false; // No geometry? Can't place.
                 }


            }

            return validPlacement;
        }

        function updateBuildPreview() {
            // (Similar logic as before, but use previewMaterialValid/Invalid)
             if (!isInBuildMode || !isPointerLocked) {
                 Object.values(buildPreviewMeshes).forEach(mesh => mesh.visible = false);
                 return;
             }

             const placement = getBuildPlacement();
             const previewMesh = buildPreviewMeshes[currentBuildType];

             if (placement && previewMesh) {
                 previewMesh.position.copy(placement.position);
                 previewMesh.rotation.copy(placement.rotation);
                 previewMesh.material = placement.canPlace ? previewMaterialValid : previewMaterialInvalid;

                 Object.entries(buildPreviewMeshes).forEach(([type, mesh]) => {
                     mesh.visible = (parseInt(type) === currentBuildType);
                 });
             } else {
                 Object.values(buildPreviewMeshes).forEach(mesh => mesh.visible = false);
             }
        }
        function updateBuildPreviewVisibility() { /* ... same as before ... */ }

        // Function to actually add build visuals/physics (used by local placement and network updates)
        function addBuildPiece(id, type, position, rotationEuler) {
             if (placedBuilds.has(id)) return; // Already exists

             const geometry = buildGeometries[type];
             const shape = buildShapes[type];
             if (!geometry || !shape) return; // Invalid type

             const mesh = new THREE.Mesh(geometry, buildMaterial.clone()); // Clone material for potential individual changes
             mesh.position.copy(position);
             mesh.rotation.copy(rotationEuler);
             mesh.castShadow = true;
             mesh.receiveShadow = true;
             mesh.userData = { id: id, type: 'build', buildType: type }; // Store ID and type on mesh
             scene.add(mesh);

             const quaternion = new CANNON.Quaternion().setFromEuler(rotationEuler.x, rotationEuler.y, rotationEuler.z, 'XYZ');

             // Special rotation for Ramp physics body
             if (type === BuildType.RAMP) {
                 const rampQuaternion = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 4);
                 quaternion.mult(rampQuaternion, quaternion);
             }
            // Special rotation for Cone physics body (align cylinder Y with mesh Y)
             if (type === BuildType.CONE) {
                 // Cone Geometry's height is along Y, Cannon Cylinder's height is along Y.
                 // But THREE.ConeGeometry pivot is at base, CANNON.Cylinder pivot is center.
                 // Adjust physics body position slightly upwards.
                 position = position.clone().add(new THREE.Vector3(0, coneHeight / 2, 0));
                 // Rotation needs to align CANNON Cylinder axis with THREE Cone axis (already aligned if using Y-up)
                  // Ensure the CANNON.Cylinder shape is created with height along Y. (It is by default)
             }


             const body = new CANNON.Body({
                 mass: 0,
                 position: new CANNON.Vec3(position.x, position.y, position.z),
                 shape: shape,
                 material: baseMaterial,
                 quaternion: quaternion
             });
             body.userData = { id: id, type: 'build', buildType: type }; // Store ID and type on body
             physicsWorld.addBody(body);

             const newBuild = {
                 id: id,
                 mesh: mesh,
                 body: body,
                 health: buildHealth[type] || 100, // Assign health
                 type: type
             };
             placedBuilds.set(id, newBuild);
             return newBuild;
        }


         function placeBuild() {
            const placement = getBuildPlacement();
            if (!placement || !placement.canPlace) return;

             // Optimistically place locally first
             const localBuildId = `local_${nextBuildId++}`; // Temporary local ID
             const placed = addBuildPiece(localBuildId, currentBuildType, placement.position, placement.rotation);

            if (placed && ws && ws.readyState === WebSocket.OPEN) {
                 // Send build action to server
                 sendMessage({
                     type: 'PLACE_BUILD',
                     payload: {
                         // tempId: localBuildId, // Server can assign final ID
                         buildType: currentBuildType,
                         position: { x: placement.position.x, y: placement.position.y, z: placement.position.z },
                         rotation: { x: placement.rotation.x, y: placement.rotation.y, z: placement.rotation.z }
                     }
                 });
                 playBuildSound();
             } else if (!placed) {
                 // TODO: Handle placement failure (maybe UI feedback)
             } else {
                 // If offline, placement still works locally
                 playBuildSound();
             }

         }

         // Function to remove build visuals/physics (used by local destruction and network updates)
         function removeBuildPiece(id) {
            const build = placedBuilds.get(id);
            if (!build) return;

            if (build.mesh) scene.remove(build.mesh);
            if (build.body) physicsWorld.removeBody(build.body);

             // Attempt to dispose resources
             if (build.mesh && build.mesh.geometry) build.mesh.geometry.dispose();
             if (build.mesh && build.mesh.material) {
                 // Check if material is shared before disposing maps? Complex. Assume individual clones for now.
                 if(Array.isArray(build.mesh.material)) build.mesh.material.forEach(m => m.dispose());
                 else build.mesh.material.dispose();
             }

            placedBuilds.delete(id);
         }

        function damageBuild(id, damage) {
            const build = placedBuilds.get(id);
            if (!build) return;

            build.health -= damage;
            console.log(`Build ${id} health: ${build.health}`);

             // Optional: Visual feedback for damage (e.g., change color, add decals)
             if (build.mesh.material && build.health > 0) {
                 // Flash white briefly
                 const originalColor = build.mesh.material.color.clone();
                 build.mesh.material.color.set(0xffffff);
                 setTimeout(() => {
                     if (build.mesh && build.mesh.material) { // Check if still exists
                         build.mesh.material.color.copy(originalColor);
                     }
                 }, 80);
             }

            if (build.health <= 0) {
                 console.log(`Destroying build ${id}`);
                 removeBuildPiece(id); // Remove locally first
                 playDestroySound();

                 // Tell the server this build was destroyed (if online)
                 if (ws && ws.readyState === WebSocket.OPEN) {
                    sendMessage({ type: 'DESTROY_BUILD', payload: { id: id } });
                 }
            }
        }


        // --- Shooting Logic ---
        function shoot() {
             // (Sound, Raycast setup similar to before)
             playShootSound();
             raycaster.setFromCamera({ x: 0, y: 0 }, camera);

             // Send shoot action to server immediately (server handles hit detection ideally)
             if (ws && ws.readyState === WebSocket.OPEN) {
                 sendMessage({
                     type: 'SHOOT',
                     payload: {
                         origin: { x: raycaster.ray.origin.x, y: raycaster.ray.origin.y, z: raycaster.ray.origin.z },
                         direction: { x: raycaster.ray.direction.x, y: raycaster.ray.direction.y, z: raycaster.ray.direction.z }
                     }
                 });
             }

             // Client-side prediction / effects
             const intersects = raycaster.intersectObjects(scene.children, true);
             let hitPoint = null;
             let hitObject = null;
             let hitBodyId = null; // For identifying builds/players hit

            for (const intersect of intersects) {
                 if (intersect.object === playerGroup || intersect.object.parent === playerGroup || // Ignore local player mesh parts
                     Object.values(buildPreviewMeshes).includes(intersect.object) ||
                     intersect.distance < 0.5) continue;

                 hitPoint = intersect.point;
                 hitObject = intersect.object; // THREE mesh

                 // Try to find corresponding physics body/ID if it's a build or player
                 if (hitObject.userData && hitObject.userData.id) {
                    hitBodyId = hitObject.userData.id;
                 } else if (hitObject.parent && hitObject.parent.userData && hitObject.parent.userData.id){ // Check parent group (like other players)
                    hitBodyId = hitObject.parent.userData.id;
                 }

                 // Client-side damage prediction for builds
                 if (hitBodyId && placedBuilds.has(hitBodyId)) {
                     // Apply damage locally for immediate feedback - server state is authoritative
                     // damageBuild(hitBodyId, shootDamage); // Server should confirm damage
                     console.log(`Client predicted hit on build: ${hitBodyId}`);
                     playImpactSound(); // Play impact locally
                 } else if (hitBodyId && otherPlayers.has(hitBodyId)) {
                     console.log(`Client predicted hit on player: ${hitBodyId}`);
                     playImpactSound();
                 } else {
                     playImpactSound(); // Hit environment
                 }

                 break; // Stop at first valid hit
             }

            // Visual Effects (Tracer/Impact Sphere - same as before)
             const tracerMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8, depthWrite: false });
             const startPoint = raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 0.2); // Start slightly ahead
             const endPoint = hitPoint ? hitPoint : raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 100);
             const tracerGeometry = new THREE.BufferGeometry().setFromPoints([startPoint, endPoint]);
             const tracerLine = new THREE.Line(tracerGeometry, tracerMaterial);
             scene.add(tracerLine);

             if (hitPoint) { /* ... Add impact sphere visual ... */
                 const impactGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                 const impactMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, depthWrite: false });
                 const impactSphere = new THREE.Mesh(impactGeometry, impactMaterial);
                 impactSphere.position.copy(hitPoint);
                 scene.add(impactSphere);
                 setTimeout(() => { scene.remove(impactSphere); impactMaterial.dispose(); impactGeometry.dispose(); }, 150);
             }
             setTimeout(() => { scene.remove(tracerLine); tracerMaterial.dispose(); tracerGeometry.dispose(); }, 100);
        }


        // --- Networking ---
        function connectWebSocket() {
             // Use ws:// for local testing, wss:// for deployed secure connections
             // Replace with your actual Vercel backend URL when deployed
             // const socketUrl = 'ws://localhost:8080'; // Example local URL
              const socketUrl = 'wss://YOUR_VERCEL_DEPLOYMENT_URL'; // <<< --- REPLACE THIS

             if (!socketUrl.includes('YOUR_VERCEL')) {
                connectionStatusElement.textContent = `Connecting to ${socketUrl}...`;
                ws = new WebSocket(socketUrl);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    connectionStatusElement.textContent = 'Connected';
                    connectionStatusElement.style.color = '#00ff00';
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleServerMessage(message);
                    } catch (error) {
                        console.error('Failed to parse server message:', event.data, error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    connectionStatusElement.textContent = 'Connection Error';
                    connectionStatusElement.style.color = '#ff0000';
                };

                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    connectionStatusElement.textContent = 'Disconnected';
                    connectionStatusElement.style.color = '#ffcc00';
                    localPlayerId = null;
                    // Clear other players? Or leave ghosts?
                    otherPlayers.forEach(p => { if(p.mesh) scene.remove(p.mesh); });
                    otherPlayers.clear();
                     // Maybe attempt reconnect after a delay?
                     // setTimeout(connectWebSocket, 5000);
                };
             } else {
                 connectionStatusElement.textContent = 'Configure Backend URL!';
                 connectionStatusElement.style.color = '#ff0000';
             }

        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            } else {
                console.warn("WebSocket not open. Message not sent:", message);
            }
        }

         function handleServerMessage(message) {
            // console.log("Received:", message); // Debugging
             switch (message.type) {
                 case 'ASSIGN_ID':
                     localPlayerId = message.payload.id;
                     playerBody.userData.id = localPlayerId; // Assign to physics body too
                     console.log(`Assigned Player ID: ${localPlayerId}`);
                     // Send initial state? Or server requests it?
                     break;

                 case 'GAME_STATE': // Initial state sync
                     // Load existing players
                     message.payload.players.forEach(pState => {
                         if (pState.id !== localPlayerId) {
                             updateOtherPlayer(pState);
                         }
                     });
                     // Load existing builds
                      placedBuilds.forEach(b => removeBuildPiece(b.id)); // Clear local builds first? Or merge? Depends on server logic.
                      placedBuilds.clear();
                      message.payload.builds.forEach(bState => {
                         addBuildPiece(bState.id, bState.type, new THREE.Vector3(bState.position.x, bState.position.y, bState.position.z), new THREE.Euler(bState.rotation.x, bState.rotation.y, bState.rotation.z, 'XYZ'));
                         // Maybe update health too if included: placedBuilds.get(bState.id).health = bState.health;
                      });
                     break;

                 case 'PLAYER_JOIN':
                     if (message.payload.id !== localPlayerId) {
                         console.log(`Player joined: ${message.payload.id}`);
                         updateOtherPlayer(message.payload); // Add/update player data
                     }
                     break;

                 case 'PLAYER_LEAVE':
                     console.log(`Player left: ${message.payload.id}`);
                     const playerToRemove = otherPlayers.get(message.payload.id);
                     if (playerToRemove) {
                         if (playerToRemove.mesh) scene.remove(playerToRemove.mesh);
                         otherPlayers.delete(message.payload.id);
                     }
                     break;

                 case 'PLAYER_UPDATE': // Player movement/rotation update
                     if (message.payload.id !== localPlayerId) {
                         updateOtherPlayer(message.payload);
                     }
                     break;

                 case 'BUILD_PLACED': // Confirmation/broadcast of a build placement
                     console.log('Build placed confirmation:', message.payload);
                      // If this client placed it with a temp ID, might need to update the ID map? Complex.
                      // Simplest: Assume server sends final state for all builds.
                      addBuildPiece(message.payload.id, message.payload.type, new THREE.Vector3(message.payload.position.x, message.payload.position.y, message.payload.position.z), new THREE.Euler(message.payload.rotation.x, message.payload.rotation.y, message.payload.rotation.z, 'XYZ'));
                     break;

                 case 'BUILD_DESTROYED': // Broadcast of build destruction
                     console.log('Build destroyed confirmation:', message.payload);
                     removeBuildPiece(message.payload.id);
                     break;

                 case 'PLAYER_DAMAGE': // You were hit
                      if (message.payload.targetId === localPlayerId) {
                          console.log(`Took ${message.payload.damage} damage!`);
                          // TODO: Update local player health UI / visual effect
                      }
                      break;
                 case 'BUILD_DAMAGE': // A build was hit
                      const build = placedBuilds.get(message.payload.buildId);
                      if(build) {
                          build.health = message.payload.newHealth; // Update health from server
                          console.log(`Build ${message.payload.buildId} damaged, health: ${build.health}`);
                          // Add damage effect?
                      }
                      break;

                 default:
                     console.warn(`Unknown message type: ${message.type}`);
             }
         }

         function updateOtherPlayer(playerState) {
            let player = otherPlayers.get(playerState.id);
            if (!player) {
                 // New player
                 player = {
                     mesh: createOtherPlayerMesh(),
                     targetPosition: new THREE.Vector3(),
                     targetQuaternion: new THREE.Quaternion(),
                     // Could add a simple physics body for collision if needed, but complicates things
                 };
                 player.mesh.userData = { id: playerState.id, type: 'player' }; // Link ID
                 otherPlayers.set(playerState.id, player);
             }

            // Store target state sent by server
             if (playerState.position) player.targetPosition.set(playerState.position.x, playerState.position.y, playerState.position.z);
             if (playerState.quaternion) player.targetQuaternion.set(playerState.quaternion.x, playerState.quaternion.y, playerState.quaternion.z, playerState.quaternion.w);

            // Make mesh visible
             if (player.mesh) player.mesh.visible = true;
         }

         // Send player state periodically
         const networkUpdateInterval = 100; // ms (e.g., 10 times per second)
         let lastNetworkUpdateTime = 0;

         function sendPlayerState() {
            if (!localPlayerId || !ws || ws.readyState !== WebSocket.OPEN) return;

             // Send position and rotation (quaternion is better for rotation)
             const currentPos = playerBody.position;
             const currentQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, cameraYaw, 0)); // Send camera yaw as player facing direction

            sendMessage({
                 type: 'PLAYER_MOVE',
                 payload: {
                     position: { x: currentPos.x, y: currentPos.y, z: currentPos.z },
                     quaternion: { x: currentQuat.x, y: currentQuat.y, z: currentQuat.z, w: currentQuat.w }
                 }
             });
         }

        // --- Game Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); // Clamp delta time

            // --- Input & Local Player Movement ---
             // (Movement direction calculation similar to before, using camera direction)
             const moveDirection = new THREE.Vector3(0, 0, 0);
             const forward = new THREE.Vector3();
             const right = new THREE.Vector3();
             camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
             right.crossVectors(new THREE.Vector3(0,1,0), forward).normalize(); // Use world UP

             if (keys['KeyW']) moveDirection.add(forward);
             if (keys['KeyS']) moveDirection.sub(forward);
             if (keys['KeyA']) moveDirection.sub(right);
             if (keys['KeyD']) moveDirection.add(right);
             moveDirection.normalize();

             // Apply velocity directly for responsiveness
             const currentVelocity = playerBody.velocity;
             playerBody.velocity.x = moveDirection.x * moveSpeed;
             playerBody.velocity.z = moveDirection.z * moveSpeed;

            // --- Jumping ---
             const grounded = checkGrounded();
             // (Landing sound logic if needed)
             if (grounded && wasAirborne) wasAirborne = false;
             else if (!grounded) wasAirborne = true;
             canJump = grounded;

             if (keys['Space'] && canJump && localPlayerId) { // Can only jump if connected/identified
                 playerBody.velocity.y = jumpForce;
                 canJump = false; wasAirborne = true;
                 playJumpSound();
                 // Send jump action? Or let server derive from Y velocity? Depends on server logic.
                 // sendMessage({ type: 'JUMP' });
             }

             // --- Arrow Key Camera ---
             // (Arrow key logic as before)


            // --- Update Physics ---
            physicsWorld.step(1 / 60, deltaTime, 3);

            // --- Sync Local Player Mesh ---
             playerGroup.position.copy(playerBody.position);
             playerGroup.position.y -= playerHeight / 2; // Adjust for model pivot point
             // Rotate player model group based on camera yaw
             playerGroup.rotation.y = cameraYaw + Math.PI;


            // --- Update Other Players (Interpolation) ---
             otherPlayers.forEach(player => {
                 if (player.mesh && player.mesh.visible) {
                     player.mesh.position.lerp(player.targetPosition, 0.15); // Smooth position
                      player.mesh.quaternion.slerp(player.targetQuaternion, 0.15); // Smooth rotation (Spherical Lerp)
                 }
             });

            // --- Update Build Preview ---
            updateBuildPreview();

            // --- Update Camera ---
            const playerHeadPos = new THREE.Vector3();
            playerGroup.children[1].getWorldPosition(playerHeadPos); // Get head mesh world position

            // Apply shoulder offset relative to camera's right direction
             const camRight = new THREE.Vector3().crossVectors(camera.up, camera.getWorldDirection(new THREE.Vector3()).negate()).normalize();
             const shoulderOffsetWorld = camRight.multiplyScalar(cameraShoulderOffset.x)
                                            .add(camera.up.clone().multiplyScalar(cameraShoulderOffset.y));

            const targetFocusPoint = playerHeadPos.clone().add(shoulderOffsetWorld); // Aim slightly offset from head
             cameraTarget.lerp(targetFocusPoint, 0.2); // Smoothly move the point the camera *looks at*


             // Calculate desired camera position
            const cameraOffset = new THREE.Vector3(shoulderOffsetWorld.x, shoulderOffsetWorld.y, cameraDistance); // Apply offset base
            cameraOffset.applyAxisAngle(new THREE.Vector3(1, 0, 0), cameraPitch);
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);

             const desiredCameraPosition = playerHeadPos.clone().add(cameraOffset);


             // Camera Collision (Raycast from target focus point towards desired position)
             const camRayStart = targetFocusPoint; // Start ray from where camera looks
             const camRayDir = desiredCameraPosition.clone().sub(camRayStart).normalize();
             const camRay = new CANNON.Ray(new CANNON.Vec3(camRayStart.x, camRayStart.y, camRayStart.z), new CANNON.Vec3(camRayDir.x, camRayDir.y, camRayDir.z));
             camRay.to = new CANNON.Vec3(desiredCameraPosition.x, desiredCameraPosition.y, desiredCameraPosition.z);
             const camResult = new CANNON.RaycastResult();
             // Important: Filter out the local player's physics body from camera collision!
             const camOptions = {
                 skipBackfaces: true,
                 collisionFilterMask: -1, // Check everything initially
                 collisionFilterGroup: -1, // Check everything initially
                // We need to ignore the playerBody ID
                // This requires modifying cannon-es or using collision groups properly
                // Simple hack: Raycast then check if hitBody === playerBody (less efficient)
             };
             physicsWorld.raycastClosest(camRay.from, camRay.to, camOptions, camResult);

             let finalCameraDist = cameraDistance;
             if (camResult.hasHit && camResult.body !== playerBody) { // Check if hit and it's not the player
                 const hitDist = camRayStart.distanceTo(camResult.hitPointWorld);
                 finalCameraDist = Math.max(hitDist - 0.2, 0.5); // Pull camera in, ensure min distance
             }

             // Set final position based on calculated distance
             camera.position.copy(camRayStart).addScaledVector(camRayDir, finalCameraDist);
             camera.lookAt(cameraTarget); // Ensure camera always looks at the smoothed target


            // --- Send Network Updates Periodically ---
            if (time - lastNetworkUpdateTime > networkUpdateInterval) {
                 sendPlayerState();
                 lastNetworkUpdateTime = time;
             }

            // --- Render ---
            renderer.render(scene, camera);
        }

        // --- Resize Listener ---
        window.addEventListener('resize', () => { /* ... same as before ... */ });

        // --- Initialization ---
        connectWebSocket(); // Attempt to connect
        updateBuildModeUI();
        animate(0); // Start game loop

         // --- Backend Outline (Conceptual - **DO NOT RUN THIS**) ---
         /*
         // Example using Node.js and 'ws' library (on Vercel via Serverless Function)

         const WebSocket = require('ws');

         // Store game state (in memory for simple demo, persistent DB for real game)
         const players = new Map(); // { id: { ws, position, quaternion, health, etc... } }
         const builds = new Map(); // { id: { type, position, rotation, health } }
         let nextBuildIdServer = 0;

         function broadcast(message, senderWs = null) {
            const data = JSON.stringify(message);
            players.forEach(player => {
                if (player.ws !== senderWs && player.ws.readyState === WebSocket.OPEN) {
                    player.ws.send(data);
                }
            });
         }

         // Vercel Serverless Function handler (e.g., /api/websocket)
         // Needs specific setup for stateful WebSocket connections on Vercel (challenging)
         // Alternatively, use a dedicated WebSocket service or traditional server.

         export default function handler(req, res) {
             // This standard HTTP handler is NOT suitable for persistent WebSockets on Vercel.
             // You'd typically need to upgrade the connection or use Vercel's specific WebSocket handling if available.
             // The code below is illustrative of typical WebSocket server logic.
             res.status(400).send('WebSocket connection expected');
         }


         // --- Illustrative WebSocket Server Logic (Conceptual) ---

         // const wss = new WebSocket.Server({ /* ... server options ... */ });

         // wss.on('connection', (ws) => {
         //     const playerId = generateUniqueId(); // Implement ID generation
         //     console.log(`Player connected: ${playerId}`);

         //     const playerState = { ws, id: playerId, position: {x:0, y:2, z:0}, quaternion: {x:0, y:0, z:0, w:1}, health: 100 };
         //     players.set(playerId, playerState);

         //     // 1. Assign ID to new player
         //     ws.send(JSON.stringify({ type: 'ASSIGN_ID', payload: { id: playerId } }));

         //     // 2. Send current game state to new player
         //     ws.send(JSON.stringify({
         //         type: 'GAME_STATE',
         //         payload: {
         //             players: Array.from(players.values()).map(p => ({ id: p.id, position: p.position, quaternion: p.quaternion })), // Don't send 'ws' object
         //             builds: Array.from(builds.values()) // Send relevant build data
         //         }
         //     }));

         //     // 3. Inform others about the new player
         //     broadcast({ type: 'PLAYER_JOIN', payload: { id: playerId, position: playerState.position, quaternion: playerState.quaternion } }, ws);


         //     ws.on('message', (message) => {
         //         try {
         //             const data = JSON.parse(message);
         //             const currentPlayer = players.get(playerId);
         //             if (!currentPlayer) return;

         //             switch(data.type) {
         //                 case 'PLAYER_MOVE':
         //                     // Validate movement? Basic update for now.
         //                     currentPlayer.position = data.payload.position;
         //                     currentPlayer.quaternion = data.payload.quaternion;
         //                     // Broadcast update to others
         //                     broadcast({ type: 'PLAYER_UPDATE', payload: { id: playerId, position: currentPlayer.position, quaternion: currentPlayer.quaternion } }, ws);
         //                     break;

         //                 case 'PLACE_BUILD':
         //                     // Validate placement? Check resources?
         //                     const buildId = `build_${nextBuildIdServer++}`;
         //                     const newBuild = {
         //                         id: buildId,
         //                         type: data.payload.buildType,
         //                         position: data.payload.position,
         //                         rotation: data.payload.rotation,
         //                         health: 100 // Get from defaults
         //                     };
         //                     builds.set(buildId, newBuild);
         //                     // Broadcast placement to all players (including originator for ID confirmation)
         //                     broadcast({ type: 'BUILD_PLACED', payload: newBuild }, null); // Send to all
         //                     break;

         //                  case 'DESTROY_BUILD':
         //                       // Validate? Check if build exists?
         //                       if (builds.has(data.payload.id)) {
         //                           builds.delete(data.payload.id);
         //                           broadcast({ type: 'BUILD_DESTROYED', payload: { id: data.payload.id } }, null);
         //                       }
         //                       break;

         //                  case 'SHOOT':
         //                       // Server-side hit detection (raycast against world state)
         //                       // Determine hit player or build
         //                       // Apply damage, update health
         //                       // Broadcast damage/hit confirmation message(s)
         //                       // Example: broadcast({ type: 'PLAYER_DAMAGE', payload: { targetId: 'hitPlayerId', damage: 25 } });
         //                       // Example: broadcast({ type: 'BUILD_DAMAGE', payload: { buildId: 'hitBuildId', newHealth: 75 } });
         //                       break;

         //                  // Add other message handlers (Jump, etc.)
         //             }

         //         } catch (e) { console.error('Failed to process message:', e); }
         //     });

         //     ws.on('close', () => {
         //         console.log(`Player disconnected: ${playerId}`);
         //         players.delete(playerId);
         //         broadcast({ type: 'PLAYER_LEAVE', payload: { id: playerId } }, null);
         //     });

         //     ws.onerror = (err) => {
         //         console.error(`WebSocket error for player ${playerId}:`, err);
         //         // Clean up if connection drops unexpectedly
         //         if (players.has(playerId)) {
         //             players.delete(playerId);
         //             broadcast({ type: 'PLAYER_LEAVE', payload: { id: playerId } }, null);
         //         }
         //     };
         // });


         */


    </script>
</body>
</html>
